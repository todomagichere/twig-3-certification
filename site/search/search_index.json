{"config":{"indexing":"full","lang":["es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Summary Info NOTE: The Twig 3 Certification exam only includes questions about the core features and syntax of Twig 3. It does not contain questions about official Twig extensions such as Html, Intl, Inky, String, etc. This summary is extracted from Twig certification official page Basic Concepts Basic Twig concepts Twig syntax Escaping Filters Built-in Twig filters and their parameters Chaining filters Alternative filter syntax Tests Built-in Twig tests Combining tests and conditional expressions Control Structures Loops Conditionals Combining loops and conditionals Variables and Expressions Defining variables Accessing simple and complex variables Expressions Functions Built-in Twig functions and their arguments Operators Built-in Twig operators Combining operators Template Re-use Basic and multi-level inheritance Including template fragment Embedding templates","title":"Summary"},{"location":"#summary","text":"Info NOTE: The Twig 3 Certification exam only includes questions about the core features and syntax of Twig 3. It does not contain questions about official Twig extensions such as Html, Intl, Inky, String, etc. This summary is extracted from Twig certification official page","title":"Summary"},{"location":"#basic-concepts","text":"Basic Twig concepts Twig syntax Escaping","title":"Basic Concepts"},{"location":"#filters","text":"Built-in Twig filters and their parameters Chaining filters Alternative filter syntax","title":"Filters"},{"location":"#tests","text":"Built-in Twig tests Combining tests and conditional expressions","title":"Tests"},{"location":"#control-structures","text":"Loops Conditionals Combining loops and conditionals","title":"Control Structures"},{"location":"#variables-and-expressions","text":"Defining variables Accessing simple and complex variables Expressions","title":"Variables and Expressions"},{"location":"#functions","text":"Built-in Twig functions and their arguments","title":"Functions"},{"location":"#operators","text":"Built-in Twig operators Combining operators","title":"Operators"},{"location":"#template-re-use","text":"Basic and multi-level inheritance Including template fragment Embedding templates","title":"Template Re-use"},{"location":"defining_variables/","text":"Setting a variable Inside code blocks you can also assign values to variables. Assignments use the set tag and can have multiple targets. Here is how you can assign the bar value to the foo variable: {% set foo = 'bar' %} After the set call, the foo variable is available in the template like any other ones: {# displays bar #} {{ foo }} The assigned value can be any valid Twig expression: {% set foo = [1, 2] %} {% set foo = {'foo': 'bar'} %} {% set foo = 'foo' ~ 'bar' %} Several variables can be assigned in one block: {% set foo, bar = 'foo', 'bar' %} {# is equivalent to #} {% set foo = 'foo' %} {% set bar = 'bar' %} The set tag can also be used to 'capture' chunks of text: {% set foo %} <div id=\"pagination\"> ... </div> {% endset %} Caution If you enable automatic output escaping, Twig will only consider the content to be safe when capturing chunks of text. Note that loops are scoped in Twig; therefore a variable declared inside a for loop is not accessible outside the loop itself: {% for item in list %} {% set foo = item %} {% endfor %} {# foo is NOT available #} If you want to access the variable, just declare it before the loop: {% set foo = \"\" %} {% for item in list %} {% set foo = item %} {% endfor %} {# foo is available #}","title":"Defining variables"},{"location":"defining_variables/#setting-a-variable","text":"Inside code blocks you can also assign values to variables. Assignments use the set tag and can have multiple targets. Here is how you can assign the bar value to the foo variable: {% set foo = 'bar' %} After the set call, the foo variable is available in the template like any other ones: {# displays bar #} {{ foo }} The assigned value can be any valid Twig expression: {% set foo = [1, 2] %} {% set foo = {'foo': 'bar'} %} {% set foo = 'foo' ~ 'bar' %} Several variables can be assigned in one block: {% set foo, bar = 'foo', 'bar' %} {# is equivalent to #} {% set foo = 'foo' %} {% set bar = 'bar' %} The set tag can also be used to 'capture' chunks of text: {% set foo %} <div id=\"pagination\"> ... </div> {% endset %} Caution If you enable automatic output escaping, Twig will only consider the content to be safe when capturing chunks of text. Note that loops are scoped in Twig; therefore a variable declared inside a for loop is not accessible outside the loop itself: {% for item in list %} {% set foo = item %} {% endfor %} {# foo is NOT available #} If you want to access the variable, just declare it before the loop: {% set foo = \"\" %} {% for item in list %} {% set foo = item %} {% endfor %} {# foo is available #}","title":"Setting a variable"},{"location":"expressions/","text":"","title":"Expressions"},{"location":"operators/","text":"Operators In The in operator performs containment test. It returns true if the left operand is contained in the right: {{ 1 in [1, 2, 3] }} {{ 'cd' in 'abcde' }} {# both returns true #} Tip You can use this filter to perform a containment test on strings, arrays, or objects implementing the Traversable interface. To perform a negative test, use the not in operator: {% if 1 not in [1, 2, 3] %} {# is equivalent to #} {% if not (1 in [1, 2, 3]) %} Is (Test operator) The is operator performs tests. Tests can be used to test a variable against a common expression. The right operand is name of the test: {# find out if a variable is odd #} {{ name is odd }} Go to the tests page to learn more about the built-in tests. | Applies a filter {% set myVariable = \"foobar\" %} {{ myVariable|upper }} {# displays FOOBAR #} .. Creates a sequence based on the operand before and after the operator (this is syntactic sugar for the range function): {% for i in 1..5 %}{{ i }}{% endfor %} {# is equivalent to #} {% for i in range(1, 5) %}{{ i }}{% endfor %} ~ Converts all operands into strings and concatenates them. {% set name = \"John\" %} {{ \"Hello\" ~ name ~ \"!\" }} {# displays Hello John!. #} . or [] Gets an attribute of a variable. {{ array.name }} {{ array['name'] }} ?: Ternary operator: {{ foo ? 'yes' : 'no' }} {{ foo ?: 'no' }} is the same as {{ foo ? foo : 'no' }} {{ foo ? 'yes' }} is the same as {{ foo ? 'yes' : '' }} ?? Null-coalescing operator: {# returns the value of foo if it is defined and not null, 'no' otherwise #} {{ foo ?? 'no' }} ... The spread operator can be used to expand arrays or hashes (it cannot be used to expand the arguments of a function call): {% set numbers = [1, 2, ...moreNumbers] %} {% set ratings = { 'foo': 10, 'bar': 5, ...moreRatings } %} Math Twig allows you to do math in templates; the following operators are supported: + Adds two numbers together (the operands are casted to numbers). {{ 1 + 1 }} is 2. - Subtracts the second number from the first one. {{ 3 - 2 }} is 1. / Divides two numbers. The returned value will be a floating point number. {{ 1 / 2 }} is {{ 0.5 }}. % Calculates the remainder of an integer division. {{ 11 % 7 }} is 4. // Divides two numbers and returns the floored integer result. {{ 20 // 7 }} is 2, {{ -20 // 7 }} is -3 (this is just syntactic sugar for the round filter). * Multiplies the left operand with the right one. {{ 2 * 2 }} would return 4. ** Raises the left operand to the power of the right operand. {{ 2 ** 3 }} would return 8.","title":"Built-in Twig operators"},{"location":"operators/#operators","text":"","title":"Operators"},{"location":"operators/#in","text":"The in operator performs containment test. It returns true if the left operand is contained in the right: {{ 1 in [1, 2, 3] }} {{ 'cd' in 'abcde' }} {# both returns true #} Tip You can use this filter to perform a containment test on strings, arrays, or objects implementing the Traversable interface. To perform a negative test, use the not in operator: {% if 1 not in [1, 2, 3] %} {# is equivalent to #} {% if not (1 in [1, 2, 3]) %}","title":"In"},{"location":"operators/#is-test-operator","text":"The is operator performs tests. Tests can be used to test a variable against a common expression. The right operand is name of the test: {# find out if a variable is odd #} {{ name is odd }} Go to the tests page to learn more about the built-in tests.","title":"Is (Test operator)"},{"location":"operators/#_1","text":"Applies a filter {% set myVariable = \"foobar\" %} {{ myVariable|upper }} {# displays FOOBAR #}","title":"|"},{"location":"operators/#_2","text":"Creates a sequence based on the operand before and after the operator (this is syntactic sugar for the range function): {% for i in 1..5 %}{{ i }}{% endfor %} {# is equivalent to #} {% for i in range(1, 5) %}{{ i }}{% endfor %}","title":".."},{"location":"operators/#_3","text":"Converts all operands into strings and concatenates them. {% set name = \"John\" %} {{ \"Hello\" ~ name ~ \"!\" }} {# displays Hello John!. #}","title":"~"},{"location":"operators/#or","text":"Gets an attribute of a variable. {{ array.name }} {{ array['name'] }}","title":". or []"},{"location":"operators/#_4","text":"Ternary operator: {{ foo ? 'yes' : 'no' }} {{ foo ?: 'no' }} is the same as {{ foo ? foo : 'no' }} {{ foo ? 'yes' }} is the same as {{ foo ? 'yes' : '' }}","title":"?:"},{"location":"operators/#_5","text":"Null-coalescing operator: {# returns the value of foo if it is defined and not null, 'no' otherwise #} {{ foo ?? 'no' }}","title":"??"},{"location":"operators/#_6","text":"The spread operator can be used to expand arrays or hashes (it cannot be used to expand the arguments of a function call): {% set numbers = [1, 2, ...moreNumbers] %} {% set ratings = { 'foo': 10, 'bar': 5, ...moreRatings } %}","title":"..."},{"location":"operators/#math","text":"Twig allows you to do math in templates; the following operators are supported:","title":"Math"},{"location":"operators/#_7","text":"Adds two numbers together (the operands are casted to numbers). {{ 1 + 1 }} is 2.","title":"+"},{"location":"operators/#-","text":"Subtracts the second number from the first one. {{ 3 - 2 }} is 1.","title":"-"},{"location":"operators/#_8","text":"Divides two numbers. The returned value will be a floating point number. {{ 1 / 2 }} is {{ 0.5 }}.","title":"/"},{"location":"operators/#_9","text":"Calculates the remainder of an integer division. {{ 11 % 7 }} is 4.","title":"%"},{"location":"operators/#_10","text":"Divides two numbers and returns the floored integer result. {{ 20 // 7 }} is 2, {{ -20 // 7 }} is -3 (this is just syntactic sugar for the round filter).","title":"//"},{"location":"operators/#_11","text":"Multiplies the left operand with the right one. {{ 2 * 2 }} would return 4.","title":"*"},{"location":"operators/#_12","text":"Raises the left operand to the power of the right operand. {{ 2 ** 3 }} would return 8.","title":"**"},{"location":"variables/","text":"Variables Main info The application passes variables to the templates for manipulation in the template. Variables may have attributes or elements you can access, too. The visual representation of a variable depends heavily on the application providing it. Use a dot (.) to access attributes of a variable (methods or properties of a PHP object, or items of a PHP array): {{ foo.bar }} Note It's important to know that the curly braces are not part of the variable but the print statement. When accessing variables inside tags, don't put the braces around them. If a variable or attribute does not exist, the behavior depends on the strict_variables option value (see environment options): When false , it returns null When true , it throws an exception. Implementation For convenience's sake foo.bar does the following things on the PHP layer: check if foo is an array and bar a valid element; if not, and if foo is an object, check that bar is a valid property; if not, and if foo is an object, check that bar is a valid method (even if bar is the constructor - use __construct() instead); if not, and if foo is an object, check that getBar is a valid method; if not, and if foo is an object, check that isBar is a valid method; if not, and if foo is an object, check that hasBar is a valid method; if not, and if strict_variables is false, return null; if not, throw an exception. Twig also supports a specific syntax for accessing items on PHP arrays, foo['bar']: check if foo is an array and bar a valid element; if not, and if strict_variables is false, return null; if not, throw an exception. Dynamic attribute If you want to access a dynamic attribute of a variable, use the attribute function instead. The attribute function is also useful when the attribute contains special characters (like - that would be interpreted as the minus operator): {# equivalent to the non-working foo.data-foo #} {{ attribute(foo, 'data-foo') }} Global Variables The following variables are always available in templates: _self: references the current template name ; _context: references the current context ; _charset: references the current charset .","title":"Accessing simple and complex variables"},{"location":"variables/#variables","text":"","title":"Variables"},{"location":"variables/#main-info","text":"The application passes variables to the templates for manipulation in the template. Variables may have attributes or elements you can access, too. The visual representation of a variable depends heavily on the application providing it. Use a dot (.) to access attributes of a variable (methods or properties of a PHP object, or items of a PHP array): {{ foo.bar }} Note It's important to know that the curly braces are not part of the variable but the print statement. When accessing variables inside tags, don't put the braces around them. If a variable or attribute does not exist, the behavior depends on the strict_variables option value (see environment options): When false , it returns null When true , it throws an exception.","title":"Main info"},{"location":"variables/#implementation","text":"For convenience's sake foo.bar does the following things on the PHP layer: check if foo is an array and bar a valid element; if not, and if foo is an object, check that bar is a valid property; if not, and if foo is an object, check that bar is a valid method (even if bar is the constructor - use __construct() instead); if not, and if foo is an object, check that getBar is a valid method; if not, and if foo is an object, check that isBar is a valid method; if not, and if foo is an object, check that hasBar is a valid method; if not, and if strict_variables is false, return null; if not, throw an exception. Twig also supports a specific syntax for accessing items on PHP arrays, foo['bar']: check if foo is an array and bar a valid element; if not, and if strict_variables is false, return null; if not, throw an exception.","title":"Implementation"},{"location":"variables/#dynamic-attribute","text":"If you want to access a dynamic attribute of a variable, use the attribute function instead. The attribute function is also useful when the attribute contains special characters (like - that would be interpreted as the minus operator): {# equivalent to the non-working foo.data-foo #} {{ attribute(foo, 'data-foo') }}","title":"Dynamic attribute"},{"location":"variables/#global-variables","text":"The following variables are always available in templates: _self: references the current template name ; _context: references the current context ; _charset: references the current charset .","title":"Global Variables"}]}